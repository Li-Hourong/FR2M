{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"DS%26Algorithm/","title":"Data Structure and Algorithm","text":""},{"location":"Git%26GIthub/","title":"Git and Github for version control and teamwork","text":""},{"location":"Git%26GIthub/#how-to-use-git","title":"How to use git","text":""},{"location":"Git%26GIthub/#how-to-pull-and-push-form-remote-repository","title":"How to pull and push form remote repository","text":""},{"location":"Git%26GIthub/#how-to-use-git-in-vscode","title":"How to use git in vscode","text":""},{"location":"Markdown%26Latex/","title":"Markdown and Latex for document writing and layout","text":""},{"location":"Parity%26Encrypto/","title":"Verification &amp; Encryption","text":""},{"location":"Parity%26Encrypto/#verification","title":"Verification","text":"<p>When information is tranmitted from the sender to the receiver, the receiver needs a method to check whether the information was changed during the transportation. Then we need to consider if we can recover the change. The same thing happens when information is stored somewhere like a disk, and after a period of time the information may get lost. So the problem is about three things: whether the information is changed, where the changes happened and how can we recover it.  </p>"},{"location":"Parity%26Encrypto/#parity","title":"Parity","text":"<p>Odd-even Parity is the simpliest way of parity. Suppose you have a sequence of 1 and 0 to pass from the sender to the receiver. Then the sender can make a convention with the receiver: first, append one additional bit at the end of the sequence. And whether the last bit is 1/0 is dicided by the number of 1 in the sequence so that the number of 1 in the whole sequence should be even. And if the receiver found that there are odd number of 1 in the sequence, it should be affirm that something must be wrong in the trans mission.  </p> <p>However only one additional bit can only tell the receiver whether the information is damaged, but not where the damage happens. So two-dimensional parity took place, and it can correct single-bit error in a sequence.  </p>"},{"location":"Parity%26Encrypto/#two-dimensional-parity","title":"Two-dimensional Parity","text":"<p>Suppose a single bit was changed in a sequence of d digits 1/0 sequence during transmission. To detect the position of the error, we may make a table like this:(suppose d = 15)  </p> <p>1 0 1 0 1 \u2003 1 1 0 1 1 0 \u2003 0 0 1 1 1 0 \u2003 1  </p> <p>0 0 1 0 1 \u2003 0  </p> <p>The sender can fold the whole sequence into a 3*5 table, and for each row and column set one parity bit, so that the number of 1 in every row and column should be even. So we get an additional parity row and an additonal parity colomn. From the example shown, we can easily find the 0 at (2,2) should be 1. This kind of ability to detect and correct errors is called Forward Error Correction(FEC). </p>"},{"location":"Parity%26Encrypto/#checksum","title":"Checksum","text":"<p>In the checksum verification, the whole d bit message is regarded as a sequence of k bit integer. Take Internet checksum as an example, the message is divided into 16 bits integer and the sequence of integer will be added together to generate the final checksum.The checksum will be passed together with the original message. After receiving the result, the receiver only needs to do the same operation and check if the sum is the same with the passed checksum. If not, then either the checksum or the message is changed during transmission. Checksum is actually a way of hashing the message. However these hashing methods provide a weak protection despite its low cost. Since we can't tell where the error happens and can't recover it.  So in the actual internet, the TCP and UDP use checksum while the link layer protocals use CRC.</p>"},{"location":"Parity%26Encrypto/#crc","title":"CRC","text":"<p>CRC is the abbr. of Cyclic Redundancy Check</p>"},{"location":"Parity%26Encrypto/#raid","title":"RAID","text":""},{"location":"Parity%26Encrypto/#encryption","title":"Encryption","text":"<p>The need of encryption appeared from a long time ago, when people need to tranmit some message secretly. Different encryption methods are widely used in network technologies nowadays. The main encryption technologies are Symmetric Encryption and Asymmetric Encryption.  </p>"},{"location":"Parity%26Encrypto/#symmetric-encryption","title":"Symmetric Encryption","text":"<p>Caeser encryption is a typical symmetric encryption method. The sender and the receiver take a number X they all know before passing meassages. For every character in the message, the sender change it by the character X position after the original one in the alphabet. For instance, if they choose X = 2, then all 'a' in the message will be replaced by 'c',and 'b' will be replaced by 'd', and so on. When the receiver get the message, they should replace on the opposite direction, that is replace 'c' by 'a', 'd' by 'b', and so on. So the sender and the receiver use the same way to encipher and decipher in symmetric encryption. However these encryption methods have some problems and are easy to hack. Since the X must be decided and known by both sender an receiver, but how should we pass the X secretly? And the hacker can easily guess the X since the pattern is not complicated.</p>"},{"location":"Parity%26Encrypto/#asymmetric-encryption","title":"Asymmetric Encryption","text":"<p>To explain what 'asymmetric' mean here, let's use the caeser encryption example again. To make an analogy, it's like the sender replaces 'a' by 'c' to encipher, but the receiver uses 'c'by 'b' to decipher. But how does that even possible? Let's dive into 2 actual asymmetric encryption methods: RSA and ECC.  </p>"},{"location":"Parity%26Encrypto/#rsa","title":"RSA","text":"<p>RSA encryption is named after the name of the 3 inventers. It widely used in Internet(for example SSH protocal).  </p>"},{"location":"Parity%26Encrypto/#encipher-and-decipher-process","title":"Encipher and decipher process","text":"<p>First, the sender pick 2 prime number p and q, for example p = 61, q = 53. Then calculate n = pq and \u03d5(n) = (p-1) * (q-1), in our example n = 3233 and \u03d5(n) = 3120. Second, pick the public key (e,n)  so that 1&lt; e &lt; \u03d5(n) and gcd(e,\u03d5(n))=1(which means e and \u03d5(n) are relatively prime). In our example, suppose we choose e = 17. Next, calculate the private key (d,n) d should fit the formula: e * d \u2261 1(mod \u03d5(n)), in our example we need to get d from 17 * d \u2261 1(mod 3120), which is 2753(will be explained later). Before passing message, both sides should generate their own public key: (e<sub>1</sub>,n), (e<sub>2</sub>,n) and private key: (d<sub>1</sub>,n), (d<sub>2</sub>,n). Then both sides should exchange their public key and keep their private key secret. To encipher message(let's say the number X = 65 is to be enciphered), the sender needs to calculate using the receiver's public key e<sub>2</sub>. And X<sup>e<sub>2</sub></sup> mod n = Y (65<sup>17</sup> mod 3233 = 2790) is the final enciphered result. To decipher the result Y, the receiver need it's own private key d<sub>2</sub>. The deciphered result Z = Y<sup>d<sub>2</sub></sup> mod n = 2790<sup>2753</sup> mod 3233 = 65 = X</p>"},{"location":"Parity%26Encrypto/#mathematical-foundation","title":"Mathematical foundation","text":"<p>During the process of generating public key e and private key d, the concept of modular inverse. Specifically, e and d are the modular inverse about \u03d5(n) of each other, fitting e * d \u2261 1 (mod \u03d5(n)). From  e * d \u2261 1 (mod \u03d5(n)) we can infer that e * d \u2212 1 = k * \u03d5(n)(k is some integer). So during encryption, Y = X<sup>e</sup> mod n and during decryption Z = Y<sup>d</sup> mod n = (X<sup>e</sup> mod n)<sup>d</sup> mod n = X<sup>ed</sup> mod n. Since e * d \u2212 1 = k * \u03d5(n), X<sup>ed</sup> = X<sup>1+k\u03d5(n)</sup> = X * (X<sup>\u03d5(n)</sup>)<sup>k</sup> According to Euler's theory, if X and n are relatively prime, X<sup>\u03d5(n)</sup> \u2261 1 (mod n). So X<sup>ed</sup> \u2261 X * 1<sup>k</sup> \u2261 X (mod n). Which means  Z = X<sup>ed</sup> mod n =X mod n = X (X should be guaranteed to be smaller than n) </p>"},{"location":"Parity%26Encrypto/#eulers-theory","title":"Euler's theory","text":"<p>Euler's theory claims that if a and b are 2 integer that are relatively prime(gcd(a,b) = 0), they fit the following fomular: a<sup>\u03d5(b)</sup> \u2261 1 (mod b)  (\u03d5(b) is a function that equals to the number of positive integers that are smaller than b but are relatively prime with b) In RSA algorithm, n is the multiplication of 2 prime number p and q, so only the multiple of p and q are not prime with n. So \u03d5(b) = (p-1) * (q-1)</p>"},{"location":"Parity%26Encrypto/#ecc","title":"ECC","text":"<p>ECC, or Elliptic Curve Cryptography, is another asymmetric encryption based on elliptic curve. Don't mess elliptic curve with ellipse.  Elliptic curves get it's name from the elliptic integral and look no similar like ellipse. The general representation of elliptic curves is: y<sup>2</sup> = x<sup>3</sup> + ax + b (a, b are constants that fits 4a<sup>3</sup> + 27b<sup>2</sup> \u2260 0)  The elliptic curves have some significant properties:  </p>"}]}